<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>taurunner.particle.particle API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>taurunner.particle.particle</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import proposal as pp
from importlib.resources import path

import taurunner
from taurunner.utils import units
from taurunner.cross_sections import CrossSections
from .utils import *

from proposal import Propagator
from numpy.random import RandomState
import warnings

proton_mass = ((0.9382720813+0.9395654133)/2.)*units.GeV

ID_2_name = {13:&#39;MuMinusDef&#39;, -13:&#39;MuPlusDef&#39;, 
             15:&#39;TauMinusDef&#39;, -15:&#39;TauPlusDef&#39;}
EMIN = 1e9 # minimum energy allowed in the splines
#Particle object. 
class Particle(object):
    r&#39;&#39;&#39;
    This is the class that contains all relevant 
    particle information stored in an object.
    &#39;&#39;&#39;
    def __init__(self, 
                 ID:                  int, 
                 energy:              float, 
                 incoming_angle:      float, 
                 position:            float, 
                 rand:                RandomState,
                 xs:                  CrossSections, 
                 proposal_propagator: Propagator,
                 secondaries:         bool, 
                 no_losses:           bool
                ):
        r&#39;&#39;&#39;
        Class initializer. This function sets all initial conditions based 
        on the particle&#39;s incoming angle, energy, ID, and position.

        Params
        ------
        ID                  : PDG particle identifier
        energy              : Initial energy of the particle [eV]
        incoming_angle      : Incoming_angle [radians]
        position            : Affine paramter describing the distance along the track of the particle (0&lt;x&lt;1)
        rand                : numpy random number generator
        xs                  : TauRunner CrossSections object
        proposal_propagator : PROPOSAL propagator object for moving charged lepton
        secondaries         : Boolean telling whether to include secondary (mu and e) neutrinos from tau decay
        no_losses           : Boolean to turn off charged lepton losses
        &#39;&#39;&#39;
        #Set Initial Values
        self.ID              = ID
        self.initial_energy  = energy
        self.energy          = energy
        self.position        = position
        self.chargedposition = 0.0
        self.SetParticleProperties()
        self.secondaries     = secondaries
        self.survived        = True
        self.basket          = []
        self.nCC             = 0
        self.nNC             = 0
        self.ntdecay         = 0
        self.rand            = rand
        self.xs              = xs
        self.xs_model        = xs.model
        self.propagator      = proposal_propagator
        self.losses          = not no_losses
        if ID &gt; 0:
            self.nutype = &#39;nu&#39;
        elif ID &lt; 0:
            self.nutype = &#39;nubar&#39;
        
    def SetParticleProperties(self):
        r&#39;&#39;&#39;
        Sets particle properties, either when initializing or after an interaction.
        &#39;&#39;&#39;
        if np.abs(self.ID) in [12, 14, 16]:
            self.mass = 0.0          #this is not true.. and it seems to have caused quite the stir.
            self.lifetime = np.inf   #this is unclear
        if np.abs(self.ID) == 15:
            self.mass = 1.776*units.GeV
            self.lifetime = 2.9e-13*units.sec
        if np.abs(self.ID) == 13:
            self.mass = 0.105*units.GeV
            self.livetime = 2.2e-6*units.sec

    def GetParticleId(self):
        r&#39;&#39;&#39;
        Returns the current particle ID        
        &#39;&#39;&#39;
        return self.ID

    def PrintParticleProperties(self): # pragma: no cover
        print(&#34;id&#34;, self.ID, \
              &#34;energy &#34;, self.energy/units.GeV, &#34; GeV&#34;, \
              &#34;position &#34;, self.position/units.km, &#34; km&#34;)

    def GetLifetime(self):
        r&#39;&#39;&#39;
        Returns the current particle&#39;s lifetime
        &#39;&#39;&#39;
        return self.lifetime

    def GetMass(self):
        r&#39;&#39;&#39;
        Returns the current particle&#39;s mass
        &#39;&#39;&#39;
        return self.mass

    def GetProposedDepthStep(self, p):
        r&#39;&#39;&#39;
        Calculates the free-streaming column depth of your neutrino based
        on the cross section, and then samples randomly from a log-uniform
        distribution.

        Parameters
        ------------
        p:       float
            random number. the free-streaming column depth is scaled by
            the log of this number
        Returns
        -----------
        DepthStep: float
            Column depth to interaction in natural units
        &#39;&#39;&#39;
        #Calculate the inverse of the interaction depths.
        first_piece = (1./self.GetInteractionDepth(interaction=&#39;CC&#39;))
        second_piece = (1./self.GetInteractionDepth(interaction=&#39;NC&#39;))
        step = (first_piece + second_piece)

        #return the column depth to interaction - weighted by a random number
        return -np.log(p)/step

    def GetTotalInteractionDepth(self):
        return(1./(1./self.GetInteractionDepth(interaction=&#39;NC&#39;)
               + 1./self.GetInteractionDepth(interaction=&#39;CC&#39;)))

    def GetInteractionDepth(self, interaction, proton_fraction=0.5):
        r&#39;&#39;&#39;
        Calculates the mean column depth to interaction.

        Parameters
        -----------
        interaction: str
            str defining the interaction type (CC or NC).
        Returns
        ----------
        Interaction depth: float
            mean column depth to interaction in natural units
        &#39;&#39;&#39;
        if np.abs(self.ID) in [12, 14, 16]:
            return proton_mass/(self.xs.total_cross_section(
                                                            self.energy, 
                                                            self.nutype, 
                                                            interaction,
                                                            proton_fraction=proton_fraction
                                                           )
                               )
        if np.abs(self.ID) == 15:
            raise ValueError(&#34;Tau interaction length should never be sampled.&#34;)

    def GetInteractionProbability(self,ddepth,interaction):
        return 1.-np.exp(-ddepth/self.GetInteractionDepth(interaction))

    def Decay(self):
        if np.abs(self.ID) in [12, 14, 16]:
            raise ValueError(&#34;no neutrino decays.. yet&#34;)
        if np.abs(self.ID) == 15:
            if self.secondaries:
                # sample branching ratio of tau leptonic decay
                p0 = self.rand.uniform(0,1)
                if p0 &lt; .18:
                    # sample energy of secondary antinumu
                    sample = SampleSecondariesEnergyFraction(self.rand.uniform(0,1), antinumu_cdf)
                    enu = sample*self.energy
                    # add secondary to basket, prepare propagation
                    self.basket.append({&#34;ID&#34; : -np.sign(self.ID)*14, &#34;position&#34; : self.position, &#34;energy&#34; : enu})
                elif p0 &gt; .18 and p0 &lt; .36:
                    # sample energy of secondary antinue
                    sample = SampleSecondariesEnergyFraction(self.rand.uniform(0,1), antinue_cdf)
                    enu = sample*self.energy
                    # add secondary to basket, prepare propagation
                    self.basket.append({&#34;ID&#34; : -np.sign(self.ID)*12,  &#34;position&#34; : self.position, &#34;energy&#34; : enu})
            self.energy = self.energy*self.rand.choice(TauDecayFractions, p=TauDecayWeights)
            self.ID = np.sign(self.ID)*16
            self.SetParticleProperties()
            return
        if np.abs(self.ID) in [11, 13]:
            self.survived=False

    def PropagateChargedLepton(self, body, track):
        r&#39;&#39;&#39;
        Propagate taus/mus with PROPOSAL along &#39;track&#39; through &#39;body&#39;
        Parameters
        ----------
        body: str 
            Cross section model to use for the photohadronic losses
        track: bool
            This can be set to False to turn off energy losses. In this case, the particle decays at rest.
        &#39;&#39;&#39;
        if(np.logical_or(not self.losses, np.abs(self.ID) in [11, 12])):
            return
        lep              = pp.particle.DynamicData(getattr(pp.particle, ID_2_name[self.ID])().particle_type)
        current_km_dist  = track.x_to_d(self.position)*body.radius/units.km
        total_dist       = track.x_to_d(1.-self.position)*body.radius/units.km
        current_density  = body.get_average_density(track.x_to_r(self.position))
        km_dist_to_prop  = total_dist - current_km_dist

        if(np.logical_and(np.abs(self.ID) in [13, 14], km_dist_to_prop &gt; 100.)):
             return

        lep_length  = []
        en_at_decay = []
        lep.energy     = self.energy/units.MeV
        pos_vec        = track.x_to_pp_pos(self.position, body.radius/units.cm) # radius in cm
        dir_vec        = track.x_to_pp_dir(self.position)
        lep.position   = pos_vec
        lep.direction  = dir_vec
        #propagate
        with warnings.catch_warnings():
            warnings.simplefilter(&#34;ignore&#34;)
            sec            = self.propagator.propagate(lep) #, dist_to_prop)
        particles      = sec.particles
        #update particle info
        final_vec      = (sec.position[-1] - pos_vec)
        lep_length     = final_vec.magnitude() / 1e5
        decay_products = [p for i,p in zip(range(max(len(particles)-3,0),len(particles)), particles[-3:]) if int(p.type) &lt;= 1000000001]
        en_at_decay    = np.sum([p.energy for p in decay_products])
        if(en_at_decay==0):    #particle reached the border before decaying
            self.energy = particles[-1].parent_particle_energy*units.MeV
            self.chargedposition = float(np.ceil(lep_length))
        else:                  #particle decayed before reaching the border
            self.energy    = en_at_decay*units.MeV
            self.chargedposition  = lep_length
        return sec

    def Interact(self, interaction, body=None, track=None, proton_fraction=0.5): #  dist_to_prop=None, current_density=None):
        if np.abs(self.ID) in [12, 14, 16]:
            #Sample energy lost from differential distributions
            NeutrinoInteractionWeights = self.xs.differential_cross_section(self.energy,
                                                                            NeutrinoDifferentialEnergyFractions,
                                                                            self.nutype,
                                                                            interaction,
                                                                            proton_fraction=proton_fraction
                                                    )
            NeutrinoInteractionWeights = np.divide(NeutrinoInteractionWeights, 
                                                   np.sum(NeutrinoInteractionWeights))
            z_choice = self.rand.choice(NeutrinoDifferentialEnergyFractions,
                                                       p=NeutrinoInteractionWeights)
            self.energy = z_choice*(self.energy-EMIN)+EMIN

            if interaction == &#39;CC&#39;:
                #make a charged particle
                self.nCC += 1
                self.ID = np.sign(self.ID)*(np.abs(self.ID)-1)
                if(np.abs(self.ID)==11): #electrons have no chance
                    self.survived=False
                    return
                self.SetParticleProperties()
            elif interaction == &#39;NC&#39;:
                #continue being a neutrino
                self.ID = self.ID
                self.SetParticleProperties()
                self.nNC += 1
            
            return
        else:
            raise ValueError(&#39;Particle ID not supported by this function&#39;) </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="taurunner.particle.particle.Particle"><code class="flex name class">
<span>class <span class="ident">Particle</span></span>
<span>(</span><span>ID: int, energy: float, incoming_angle: float, position: float, rand: mtrand.RandomState, xs: <a title="taurunner.cross_sections.xs_model.XSModel" href="../cross_sections/xs_model.html#taurunner.cross_sections.xs_model.XSModel">XSModel</a>, proposal_propagator: proposal.Propagator, secondaries: bool, no_losses: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the class that contains all relevant
particle information stored in an object.</p>
<p>Class initializer. This function sets all initial conditions based
on the particle's incoming angle, energy, ID, and position.</p>
<h2 id="params">Params</h2>
<p>ID
: PDG particle identifier
energy
: Initial energy of the particle [eV]
incoming_angle
: Incoming_angle [radians]
position
: Affine paramter describing the distance along the track of the particle (0&lt;x&lt;1)
rand
: numpy random number generator
xs
: TauRunner CrossSections object
proposal_propagator : PROPOSAL propagator object for moving charged lepton
secondaries
: Boolean telling whether to include secondary (mu and e) neutrinos from tau decay
no_losses
: Boolean to turn off charged lepton losses</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Particle(object):
    r&#39;&#39;&#39;
    This is the class that contains all relevant 
    particle information stored in an object.
    &#39;&#39;&#39;
    def __init__(self, 
                 ID:                  int, 
                 energy:              float, 
                 incoming_angle:      float, 
                 position:            float, 
                 rand:                RandomState,
                 xs:                  CrossSections, 
                 proposal_propagator: Propagator,
                 secondaries:         bool, 
                 no_losses:           bool
                ):
        r&#39;&#39;&#39;
        Class initializer. This function sets all initial conditions based 
        on the particle&#39;s incoming angle, energy, ID, and position.

        Params
        ------
        ID                  : PDG particle identifier
        energy              : Initial energy of the particle [eV]
        incoming_angle      : Incoming_angle [radians]
        position            : Affine paramter describing the distance along the track of the particle (0&lt;x&lt;1)
        rand                : numpy random number generator
        xs                  : TauRunner CrossSections object
        proposal_propagator : PROPOSAL propagator object for moving charged lepton
        secondaries         : Boolean telling whether to include secondary (mu and e) neutrinos from tau decay
        no_losses           : Boolean to turn off charged lepton losses
        &#39;&#39;&#39;
        #Set Initial Values
        self.ID              = ID
        self.initial_energy  = energy
        self.energy          = energy
        self.position        = position
        self.chargedposition = 0.0
        self.SetParticleProperties()
        self.secondaries     = secondaries
        self.survived        = True
        self.basket          = []
        self.nCC             = 0
        self.nNC             = 0
        self.ntdecay         = 0
        self.rand            = rand
        self.xs              = xs
        self.xs_model        = xs.model
        self.propagator      = proposal_propagator
        self.losses          = not no_losses
        if ID &gt; 0:
            self.nutype = &#39;nu&#39;
        elif ID &lt; 0:
            self.nutype = &#39;nubar&#39;
        
    def SetParticleProperties(self):
        r&#39;&#39;&#39;
        Sets particle properties, either when initializing or after an interaction.
        &#39;&#39;&#39;
        if np.abs(self.ID) in [12, 14, 16]:
            self.mass = 0.0          #this is not true.. and it seems to have caused quite the stir.
            self.lifetime = np.inf   #this is unclear
        if np.abs(self.ID) == 15:
            self.mass = 1.776*units.GeV
            self.lifetime = 2.9e-13*units.sec
        if np.abs(self.ID) == 13:
            self.mass = 0.105*units.GeV
            self.livetime = 2.2e-6*units.sec

    def GetParticleId(self):
        r&#39;&#39;&#39;
        Returns the current particle ID        
        &#39;&#39;&#39;
        return self.ID

    def PrintParticleProperties(self): # pragma: no cover
        print(&#34;id&#34;, self.ID, \
              &#34;energy &#34;, self.energy/units.GeV, &#34; GeV&#34;, \
              &#34;position &#34;, self.position/units.km, &#34; km&#34;)

    def GetLifetime(self):
        r&#39;&#39;&#39;
        Returns the current particle&#39;s lifetime
        &#39;&#39;&#39;
        return self.lifetime

    def GetMass(self):
        r&#39;&#39;&#39;
        Returns the current particle&#39;s mass
        &#39;&#39;&#39;
        return self.mass

    def GetProposedDepthStep(self, p):
        r&#39;&#39;&#39;
        Calculates the free-streaming column depth of your neutrino based
        on the cross section, and then samples randomly from a log-uniform
        distribution.

        Parameters
        ------------
        p:       float
            random number. the free-streaming column depth is scaled by
            the log of this number
        Returns
        -----------
        DepthStep: float
            Column depth to interaction in natural units
        &#39;&#39;&#39;
        #Calculate the inverse of the interaction depths.
        first_piece = (1./self.GetInteractionDepth(interaction=&#39;CC&#39;))
        second_piece = (1./self.GetInteractionDepth(interaction=&#39;NC&#39;))
        step = (first_piece + second_piece)

        #return the column depth to interaction - weighted by a random number
        return -np.log(p)/step

    def GetTotalInteractionDepth(self):
        return(1./(1./self.GetInteractionDepth(interaction=&#39;NC&#39;)
               + 1./self.GetInteractionDepth(interaction=&#39;CC&#39;)))

    def GetInteractionDepth(self, interaction, proton_fraction=0.5):
        r&#39;&#39;&#39;
        Calculates the mean column depth to interaction.

        Parameters
        -----------
        interaction: str
            str defining the interaction type (CC or NC).
        Returns
        ----------
        Interaction depth: float
            mean column depth to interaction in natural units
        &#39;&#39;&#39;
        if np.abs(self.ID) in [12, 14, 16]:
            return proton_mass/(self.xs.total_cross_section(
                                                            self.energy, 
                                                            self.nutype, 
                                                            interaction,
                                                            proton_fraction=proton_fraction
                                                           )
                               )
        if np.abs(self.ID) == 15:
            raise ValueError(&#34;Tau interaction length should never be sampled.&#34;)

    def GetInteractionProbability(self,ddepth,interaction):
        return 1.-np.exp(-ddepth/self.GetInteractionDepth(interaction))

    def Decay(self):
        if np.abs(self.ID) in [12, 14, 16]:
            raise ValueError(&#34;no neutrino decays.. yet&#34;)
        if np.abs(self.ID) == 15:
            if self.secondaries:
                # sample branching ratio of tau leptonic decay
                p0 = self.rand.uniform(0,1)
                if p0 &lt; .18:
                    # sample energy of secondary antinumu
                    sample = SampleSecondariesEnergyFraction(self.rand.uniform(0,1), antinumu_cdf)
                    enu = sample*self.energy
                    # add secondary to basket, prepare propagation
                    self.basket.append({&#34;ID&#34; : -np.sign(self.ID)*14, &#34;position&#34; : self.position, &#34;energy&#34; : enu})
                elif p0 &gt; .18 and p0 &lt; .36:
                    # sample energy of secondary antinue
                    sample = SampleSecondariesEnergyFraction(self.rand.uniform(0,1), antinue_cdf)
                    enu = sample*self.energy
                    # add secondary to basket, prepare propagation
                    self.basket.append({&#34;ID&#34; : -np.sign(self.ID)*12,  &#34;position&#34; : self.position, &#34;energy&#34; : enu})
            self.energy = self.energy*self.rand.choice(TauDecayFractions, p=TauDecayWeights)
            self.ID = np.sign(self.ID)*16
            self.SetParticleProperties()
            return
        if np.abs(self.ID) in [11, 13]:
            self.survived=False

    def PropagateChargedLepton(self, body, track):
        r&#39;&#39;&#39;
        Propagate taus/mus with PROPOSAL along &#39;track&#39; through &#39;body&#39;
        Parameters
        ----------
        body: str 
            Cross section model to use for the photohadronic losses
        track: bool
            This can be set to False to turn off energy losses. In this case, the particle decays at rest.
        &#39;&#39;&#39;
        if(np.logical_or(not self.losses, np.abs(self.ID) in [11, 12])):
            return
        lep              = pp.particle.DynamicData(getattr(pp.particle, ID_2_name[self.ID])().particle_type)
        current_km_dist  = track.x_to_d(self.position)*body.radius/units.km
        total_dist       = track.x_to_d(1.-self.position)*body.radius/units.km
        current_density  = body.get_average_density(track.x_to_r(self.position))
        km_dist_to_prop  = total_dist - current_km_dist

        if(np.logical_and(np.abs(self.ID) in [13, 14], km_dist_to_prop &gt; 100.)):
             return

        lep_length  = []
        en_at_decay = []
        lep.energy     = self.energy/units.MeV
        pos_vec        = track.x_to_pp_pos(self.position, body.radius/units.cm) # radius in cm
        dir_vec        = track.x_to_pp_dir(self.position)
        lep.position   = pos_vec
        lep.direction  = dir_vec
        #propagate
        with warnings.catch_warnings():
            warnings.simplefilter(&#34;ignore&#34;)
            sec            = self.propagator.propagate(lep) #, dist_to_prop)
        particles      = sec.particles
        #update particle info
        final_vec      = (sec.position[-1] - pos_vec)
        lep_length     = final_vec.magnitude() / 1e5
        decay_products = [p for i,p in zip(range(max(len(particles)-3,0),len(particles)), particles[-3:]) if int(p.type) &lt;= 1000000001]
        en_at_decay    = np.sum([p.energy for p in decay_products])
        if(en_at_decay==0):    #particle reached the border before decaying
            self.energy = particles[-1].parent_particle_energy*units.MeV
            self.chargedposition = float(np.ceil(lep_length))
        else:                  #particle decayed before reaching the border
            self.energy    = en_at_decay*units.MeV
            self.chargedposition  = lep_length
        return sec

    def Interact(self, interaction, body=None, track=None, proton_fraction=0.5): #  dist_to_prop=None, current_density=None):
        if np.abs(self.ID) in [12, 14, 16]:
            #Sample energy lost from differential distributions
            NeutrinoInteractionWeights = self.xs.differential_cross_section(self.energy,
                                                                            NeutrinoDifferentialEnergyFractions,
                                                                            self.nutype,
                                                                            interaction,
                                                                            proton_fraction=proton_fraction
                                                    )
            NeutrinoInteractionWeights = np.divide(NeutrinoInteractionWeights, 
                                                   np.sum(NeutrinoInteractionWeights))
            z_choice = self.rand.choice(NeutrinoDifferentialEnergyFractions,
                                                       p=NeutrinoInteractionWeights)
            self.energy = z_choice*(self.energy-EMIN)+EMIN

            if interaction == &#39;CC&#39;:
                #make a charged particle
                self.nCC += 1
                self.ID = np.sign(self.ID)*(np.abs(self.ID)-1)
                if(np.abs(self.ID)==11): #electrons have no chance
                    self.survived=False
                    return
                self.SetParticleProperties()
            elif interaction == &#39;NC&#39;:
                #continue being a neutrino
                self.ID = self.ID
                self.SetParticleProperties()
                self.nNC += 1
            
            return
        else:
            raise ValueError(&#39;Particle ID not supported by this function&#39;) </code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="taurunner.particle.particle.Particle.Decay"><code class="name flex">
<span>def <span class="ident">Decay</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Decay(self):
    if np.abs(self.ID) in [12, 14, 16]:
        raise ValueError(&#34;no neutrino decays.. yet&#34;)
    if np.abs(self.ID) == 15:
        if self.secondaries:
            # sample branching ratio of tau leptonic decay
            p0 = self.rand.uniform(0,1)
            if p0 &lt; .18:
                # sample energy of secondary antinumu
                sample = SampleSecondariesEnergyFraction(self.rand.uniform(0,1), antinumu_cdf)
                enu = sample*self.energy
                # add secondary to basket, prepare propagation
                self.basket.append({&#34;ID&#34; : -np.sign(self.ID)*14, &#34;position&#34; : self.position, &#34;energy&#34; : enu})
            elif p0 &gt; .18 and p0 &lt; .36:
                # sample energy of secondary antinue
                sample = SampleSecondariesEnergyFraction(self.rand.uniform(0,1), antinue_cdf)
                enu = sample*self.energy
                # add secondary to basket, prepare propagation
                self.basket.append({&#34;ID&#34; : -np.sign(self.ID)*12,  &#34;position&#34; : self.position, &#34;energy&#34; : enu})
        self.energy = self.energy*self.rand.choice(TauDecayFractions, p=TauDecayWeights)
        self.ID = np.sign(self.ID)*16
        self.SetParticleProperties()
        return
    if np.abs(self.ID) in [11, 13]:
        self.survived=False</code></pre>
</details>
</dd>
<dt id="taurunner.particle.particle.Particle.GetInteractionDepth"><code class="name flex">
<span>def <span class="ident">GetInteractionDepth</span></span>(<span>self, interaction, proton_fraction=0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the mean column depth to interaction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>interaction</code></strong> :&ensp;<code>str</code></dt>
<dd>str defining the interaction type (CC or NC).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Interaction depth: float</code></dt>
<dd>mean column depth to interaction in natural units</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetInteractionDepth(self, interaction, proton_fraction=0.5):
    r&#39;&#39;&#39;
    Calculates the mean column depth to interaction.

    Parameters
    -----------
    interaction: str
        str defining the interaction type (CC or NC).
    Returns
    ----------
    Interaction depth: float
        mean column depth to interaction in natural units
    &#39;&#39;&#39;
    if np.abs(self.ID) in [12, 14, 16]:
        return proton_mass/(self.xs.total_cross_section(
                                                        self.energy, 
                                                        self.nutype, 
                                                        interaction,
                                                        proton_fraction=proton_fraction
                                                       )
                           )
    if np.abs(self.ID) == 15:
        raise ValueError(&#34;Tau interaction length should never be sampled.&#34;)</code></pre>
</details>
</dd>
<dt id="taurunner.particle.particle.Particle.GetInteractionProbability"><code class="name flex">
<span>def <span class="ident">GetInteractionProbability</span></span>(<span>self, ddepth, interaction)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetInteractionProbability(self,ddepth,interaction):
    return 1.-np.exp(-ddepth/self.GetInteractionDepth(interaction))</code></pre>
</details>
</dd>
<dt id="taurunner.particle.particle.Particle.GetLifetime"><code class="name flex">
<span>def <span class="ident">GetLifetime</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current particle's lifetime</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetLifetime(self):
    r&#39;&#39;&#39;
    Returns the current particle&#39;s lifetime
    &#39;&#39;&#39;
    return self.lifetime</code></pre>
</details>
</dd>
<dt id="taurunner.particle.particle.Particle.GetMass"><code class="name flex">
<span>def <span class="ident">GetMass</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current particle's mass</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetMass(self):
    r&#39;&#39;&#39;
    Returns the current particle&#39;s mass
    &#39;&#39;&#39;
    return self.mass</code></pre>
</details>
</dd>
<dt id="taurunner.particle.particle.Particle.GetParticleId"><code class="name flex">
<span>def <span class="ident">GetParticleId</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current particle ID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetParticleId(self):
    r&#39;&#39;&#39;
    Returns the current particle ID        
    &#39;&#39;&#39;
    return self.ID</code></pre>
</details>
</dd>
<dt id="taurunner.particle.particle.Particle.GetProposedDepthStep"><code class="name flex">
<span>def <span class="ident">GetProposedDepthStep</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the free-streaming column depth of your neutrino based
on the cross section, and then samples randomly from a log-uniform
distribution.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p</code></strong> :&ensp;<code>
float</code></dt>
<dd>random number. the free-streaming column depth is scaled by
the log of this number</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>DepthStep</code></strong> :&ensp;<code>float</code></dt>
<dd>Column depth to interaction in natural units</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetProposedDepthStep(self, p):
    r&#39;&#39;&#39;
    Calculates the free-streaming column depth of your neutrino based
    on the cross section, and then samples randomly from a log-uniform
    distribution.

    Parameters
    ------------
    p:       float
        random number. the free-streaming column depth is scaled by
        the log of this number
    Returns
    -----------
    DepthStep: float
        Column depth to interaction in natural units
    &#39;&#39;&#39;
    #Calculate the inverse of the interaction depths.
    first_piece = (1./self.GetInteractionDepth(interaction=&#39;CC&#39;))
    second_piece = (1./self.GetInteractionDepth(interaction=&#39;NC&#39;))
    step = (first_piece + second_piece)

    #return the column depth to interaction - weighted by a random number
    return -np.log(p)/step</code></pre>
</details>
</dd>
<dt id="taurunner.particle.particle.Particle.GetTotalInteractionDepth"><code class="name flex">
<span>def <span class="ident">GetTotalInteractionDepth</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetTotalInteractionDepth(self):
    return(1./(1./self.GetInteractionDepth(interaction=&#39;NC&#39;)
           + 1./self.GetInteractionDepth(interaction=&#39;CC&#39;)))</code></pre>
</details>
</dd>
<dt id="taurunner.particle.particle.Particle.Interact"><code class="name flex">
<span>def <span class="ident">Interact</span></span>(<span>self, interaction, body=None, track=None, proton_fraction=0.5)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Interact(self, interaction, body=None, track=None, proton_fraction=0.5): #  dist_to_prop=None, current_density=None):
    if np.abs(self.ID) in [12, 14, 16]:
        #Sample energy lost from differential distributions
        NeutrinoInteractionWeights = self.xs.differential_cross_section(self.energy,
                                                                        NeutrinoDifferentialEnergyFractions,
                                                                        self.nutype,
                                                                        interaction,
                                                                        proton_fraction=proton_fraction
                                                )
        NeutrinoInteractionWeights = np.divide(NeutrinoInteractionWeights, 
                                               np.sum(NeutrinoInteractionWeights))
        z_choice = self.rand.choice(NeutrinoDifferentialEnergyFractions,
                                                   p=NeutrinoInteractionWeights)
        self.energy = z_choice*(self.energy-EMIN)+EMIN

        if interaction == &#39;CC&#39;:
            #make a charged particle
            self.nCC += 1
            self.ID = np.sign(self.ID)*(np.abs(self.ID)-1)
            if(np.abs(self.ID)==11): #electrons have no chance
                self.survived=False
                return
            self.SetParticleProperties()
        elif interaction == &#39;NC&#39;:
            #continue being a neutrino
            self.ID = self.ID
            self.SetParticleProperties()
            self.nNC += 1
        
        return
    else:
        raise ValueError(&#39;Particle ID not supported by this function&#39;) </code></pre>
</details>
</dd>
<dt id="taurunner.particle.particle.Particle.PrintParticleProperties"><code class="name flex">
<span>def <span class="ident">PrintParticleProperties</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PrintParticleProperties(self): # pragma: no cover
    print(&#34;id&#34;, self.ID, \
          &#34;energy &#34;, self.energy/units.GeV, &#34; GeV&#34;, \
          &#34;position &#34;, self.position/units.km, &#34; km&#34;)</code></pre>
</details>
</dd>
<dt id="taurunner.particle.particle.Particle.PropagateChargedLepton"><code class="name flex">
<span>def <span class="ident">PropagateChargedLepton</span></span>(<span>self, body, track)</span>
</code></dt>
<dd>
<div class="desc"><p>Propagate taus/mus with PROPOSAL along 'track' through 'body'
Parameters</p>
<hr>
<dl>
<dt><strong><code>body</code></strong> :&ensp;<code>str </code></dt>
<dd>Cross section model to use for the photohadronic losses</dd>
<dt><strong><code>track</code></strong> :&ensp;<code>bool</code></dt>
<dd>This can be set to False to turn off energy losses. In this case, the particle decays at rest.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PropagateChargedLepton(self, body, track):
    r&#39;&#39;&#39;
    Propagate taus/mus with PROPOSAL along &#39;track&#39; through &#39;body&#39;
    Parameters
    ----------
    body: str 
        Cross section model to use for the photohadronic losses
    track: bool
        This can be set to False to turn off energy losses. In this case, the particle decays at rest.
    &#39;&#39;&#39;
    if(np.logical_or(not self.losses, np.abs(self.ID) in [11, 12])):
        return
    lep              = pp.particle.DynamicData(getattr(pp.particle, ID_2_name[self.ID])().particle_type)
    current_km_dist  = track.x_to_d(self.position)*body.radius/units.km
    total_dist       = track.x_to_d(1.-self.position)*body.radius/units.km
    current_density  = body.get_average_density(track.x_to_r(self.position))
    km_dist_to_prop  = total_dist - current_km_dist

    if(np.logical_and(np.abs(self.ID) in [13, 14], km_dist_to_prop &gt; 100.)):
         return

    lep_length  = []
    en_at_decay = []
    lep.energy     = self.energy/units.MeV
    pos_vec        = track.x_to_pp_pos(self.position, body.radius/units.cm) # radius in cm
    dir_vec        = track.x_to_pp_dir(self.position)
    lep.position   = pos_vec
    lep.direction  = dir_vec
    #propagate
    with warnings.catch_warnings():
        warnings.simplefilter(&#34;ignore&#34;)
        sec            = self.propagator.propagate(lep) #, dist_to_prop)
    particles      = sec.particles
    #update particle info
    final_vec      = (sec.position[-1] - pos_vec)
    lep_length     = final_vec.magnitude() / 1e5
    decay_products = [p for i,p in zip(range(max(len(particles)-3,0),len(particles)), particles[-3:]) if int(p.type) &lt;= 1000000001]
    en_at_decay    = np.sum([p.energy for p in decay_products])
    if(en_at_decay==0):    #particle reached the border before decaying
        self.energy = particles[-1].parent_particle_energy*units.MeV
        self.chargedposition = float(np.ceil(lep_length))
    else:                  #particle decayed before reaching the border
        self.energy    = en_at_decay*units.MeV
        self.chargedposition  = lep_length
    return sec</code></pre>
</details>
</dd>
<dt id="taurunner.particle.particle.Particle.SetParticleProperties"><code class="name flex">
<span>def <span class="ident">SetParticleProperties</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets particle properties, either when initializing or after an interaction.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetParticleProperties(self):
    r&#39;&#39;&#39;
    Sets particle properties, either when initializing or after an interaction.
    &#39;&#39;&#39;
    if np.abs(self.ID) in [12, 14, 16]:
        self.mass = 0.0          #this is not true.. and it seems to have caused quite the stir.
        self.lifetime = np.inf   #this is unclear
    if np.abs(self.ID) == 15:
        self.mass = 1.776*units.GeV
        self.lifetime = 2.9e-13*units.sec
    if np.abs(self.ID) == 13:
        self.mass = 0.105*units.GeV
        self.livetime = 2.2e-6*units.sec</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="taurunner.particle" href="index.html">taurunner.particle</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="taurunner.particle.particle.Particle" href="#taurunner.particle.particle.Particle">Particle</a></code></h4>
<ul class="">
<li><code><a title="taurunner.particle.particle.Particle.Decay" href="#taurunner.particle.particle.Particle.Decay">Decay</a></code></li>
<li><code><a title="taurunner.particle.particle.Particle.GetInteractionDepth" href="#taurunner.particle.particle.Particle.GetInteractionDepth">GetInteractionDepth</a></code></li>
<li><code><a title="taurunner.particle.particle.Particle.GetInteractionProbability" href="#taurunner.particle.particle.Particle.GetInteractionProbability">GetInteractionProbability</a></code></li>
<li><code><a title="taurunner.particle.particle.Particle.GetLifetime" href="#taurunner.particle.particle.Particle.GetLifetime">GetLifetime</a></code></li>
<li><code><a title="taurunner.particle.particle.Particle.GetMass" href="#taurunner.particle.particle.Particle.GetMass">GetMass</a></code></li>
<li><code><a title="taurunner.particle.particle.Particle.GetParticleId" href="#taurunner.particle.particle.Particle.GetParticleId">GetParticleId</a></code></li>
<li><code><a title="taurunner.particle.particle.Particle.GetProposedDepthStep" href="#taurunner.particle.particle.Particle.GetProposedDepthStep">GetProposedDepthStep</a></code></li>
<li><code><a title="taurunner.particle.particle.Particle.GetTotalInteractionDepth" href="#taurunner.particle.particle.Particle.GetTotalInteractionDepth">GetTotalInteractionDepth</a></code></li>
<li><code><a title="taurunner.particle.particle.Particle.Interact" href="#taurunner.particle.particle.Particle.Interact">Interact</a></code></li>
<li><code><a title="taurunner.particle.particle.Particle.PrintParticleProperties" href="#taurunner.particle.particle.Particle.PrintParticleProperties">PrintParticleProperties</a></code></li>
<li><code><a title="taurunner.particle.particle.Particle.PropagateChargedLepton" href="#taurunner.particle.particle.Particle.PropagateChargedLepton">PropagateChargedLepton</a></code></li>
<li><code><a title="taurunner.particle.particle.Particle.SetParticleProperties" href="#taurunner.particle.particle.Particle.SetParticleProperties">SetParticleProperties</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>