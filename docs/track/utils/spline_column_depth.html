<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>taurunner.track.utils.spline_column_depth API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>taurunner.track.utils.spline_column_depth</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import warnings
import numpy as np
from scipy.interpolate import RectBivariateSpline, splev, splrep
from scipy.integrate import quad
from importlib.resources import path as imppath
import os
import pickle as pkl

from taurunner.body import construct_earth
import taurunner as tr


with imppath(&#39;taurunner.resources.column_depth_splines&#39;, &#39;__init__.py&#39;) as p:
    SPLINE_PATH = str(p).split(&#39;__init__.py&#39;)[0]


def column_depth(track,
                 body,
                 xi: float,
                 xf: float,
                 safe_mode=True
    ) -&gt; float:
    &#39;&#39;&#39;
    params
    ______
    body      : TauRunner Body object for which you want the column depth
    xi        : Affine track parameter at which to start the integeration.
    xf        : Affine track parameter at which to end the integeration.
    safe_mode : If True make sure the error on the integral is small

    returns
    _______
    column_depth : column depth on the portion of the track from xi to xf [natural units]
    &#39;&#39;&#39;
    if not (xi&lt;=xf):
        raise RuntimeError(&#39;xi must be less than or equal to xf&#39;)
    integrand = lambda x: body.get_density(track.x_to_r(x))*track.x_to_d_prime(x)*body.radius
    # find where the path intersects layer boundaries
    xx        = []
    with warnings.catch_warnings():
        warnings.simplefilter(&#34;ignore&#34;)
        for r in body.layer_boundaries:
            xx = np.append(xx, track.r_to_x(r))
    # NaNs means it does not intersect the layer
    xx        = xx[np.where(~np.isnan(xx))[0]] # non-nanize
    # Remove xs before and after the integration limits
    mask      = np.where(np.logical_and(xi&lt;xx, xx&lt;xf))[0]
    xx        = np.hstack([[xi], xx[mask], [xf]])
    II        = []
    for xi, xf in zip(xx[:-1], xx[1:]):
        I = quad(integrand, xi, xf, full_output=1)
        if safe_mode:
            if I[0]!=0:
                if I[1]/I[0]&gt;1e-3:
                    raise RuntimeError(&#39;Error too large&#39;)
        II.append(I[0])
    return np.sum(II)


# Precompute column depths when the object is initialized so that we are computing integrals
# every time
def column_depth_helper(track, body):
    xx            = np.linspace(0, 1, 301)
    column_depths = np.append(0, np.cumsum([column_depth(track, body, x[0], x[1]) for x in zip(xx[:-1], xx[1:])]))
    # Pad arrays to help spline stability
    npad          = 5
    xpad          = np.linspace(0.01, 0.05, npad)
    padded_xx     = np.hstack([-xpad[::-1], xx, 1+xpad])
    padded_cds    = np.hstack([np.full(npad, column_depths[0]), column_depths, np.full(npad, column_depths[-1])])
    # Make the splines
    x_to_X_tck    = splrep(padded_xx, padded_cds)
    x_to_X        = lambda x: splev(x, x_to_X_tck)
    
    return column_depths[-1], x_to_X

def get_hash(track, body):
    s = f&#39;{body.radius}{track.depth}&#39;
    for bd in body.layer_boundaries:
        s += str(bd)
    s = s.replace(&#39;.&#39;, &#39;&#39;)
    hash_s = s
    #print(hash(str(s)))
    #hash_s = hash(s)
    #print(s, hash_s)
    return hash_s

def spline_fname(hash_s):
    x2X_fname = f&#39;{SPLINE_PATH}/{hash_s}_x_to_X.pkl&#39;
    spline_exists = os.path.isfile(x2X_fname)
    return x2X_fname, spline_exists

def construct_X2x(x2X):
    if x2X(0)==x2X(1): # there is no bijection since derivative of this function must be non-neg
        print(x2X(0))
        if x2X(0.5)!=0: # This should only happen in the case that there is no column depth
            raise ValueError(&#39;Constant X2x is only allow for tracks with no column depth&#39;)
        else:
            def X2x(x):
                raise Exception(&#39;You should not be calling this for null propagations&#39;)
    else:
        xx         = np.linspace(0, 1, 301)
        cds        = [x2X(x) for x in xx]
        cds[0]     = 0 # Sometimes spline support can be imperfect
        X2x_tck    = splrep(cds, xx)
        def X2x(X):
            return splev(X, X2x_tck)[0]
    return X2x

def set_spline(track, body, npad=5):
    hash_s                   = get_hash(track, body)
    x2X_fname, spline_exists = spline_fname(hash_s)
    if spline_exists:
        with open(x2X_fname, &#39;rb&#39;) as pkl_file:
            x2X_spline =  pkl.load(pkl_file)
    else:
        from taurunner.track import chord
        if track.depth==0:
            skip = True
        else:
            skip = False
        ths = np.arccos(np.linspace(-1, 1, 500))
        chs = [chord(theta=th, depth=track.depth) for th in ths]
        xx  = np.linspace(0, 1, 301)
        res = np.zeros((ths.shape[0], xx.shape[0]))
        for i, ch in enumerate(chs):
            if skip and np.cos(ch.theta)&lt;=0:
                continue
            tot_X, x2X = column_depth_helper(ch, body)
            for j, x in enumerate(xx):
                res[i,j] = x2X(x)
        res[np.where(res&lt;=0)] = np.min(res[np.where(res&gt;0)])
        x2X_spline = RectBivariateSpline(np.cos(ths), xx, res, kx=2, ky=2)
        with open(x2X_fname, &#39;wb&#39;) as pkl_f:
            pkl.dump(x2X_spline, pkl_f)
    
    # reduce dimensionality of the spline to the desired theta    
    x2X = lambda x: x2X_spline(np.cos(track.theta), x)[0]
    tot_X = x2X(1)
    
    # Construct the X2x on the fly
    X2x = construct_X2x(x2X)
    
    #X2x = lambda X: X2x_spline(np.cos(track.theta), np.log(X))[0]
    track._column_depth_lookup[hash_s] = (tot_X, x2X, X2x)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="taurunner.track.utils.spline_column_depth.column_depth"><code class="name flex">
<span>def <span class="ident">column_depth</span></span>(<span>track, body, xi: float, xf: float, safe_mode=True) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>params</p>
<hr>
<p>body
: TauRunner Body object for which you want the column depth
xi
: Affine track parameter at which to start the integeration.
xf
: Affine track parameter at which to end the integeration.
safe_mode : If True make sure the error on the integral is small</p>
<p>returns</p>
<hr>
<p>column_depth : column depth on the portion of the track from xi to xf [natural units]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def column_depth(track,
                 body,
                 xi: float,
                 xf: float,
                 safe_mode=True
    ) -&gt; float:
    &#39;&#39;&#39;
    params
    ______
    body      : TauRunner Body object for which you want the column depth
    xi        : Affine track parameter at which to start the integeration.
    xf        : Affine track parameter at which to end the integeration.
    safe_mode : If True make sure the error on the integral is small

    returns
    _______
    column_depth : column depth on the portion of the track from xi to xf [natural units]
    &#39;&#39;&#39;
    if not (xi&lt;=xf):
        raise RuntimeError(&#39;xi must be less than or equal to xf&#39;)
    integrand = lambda x: body.get_density(track.x_to_r(x))*track.x_to_d_prime(x)*body.radius
    # find where the path intersects layer boundaries
    xx        = []
    with warnings.catch_warnings():
        warnings.simplefilter(&#34;ignore&#34;)
        for r in body.layer_boundaries:
            xx = np.append(xx, track.r_to_x(r))
    # NaNs means it does not intersect the layer
    xx        = xx[np.where(~np.isnan(xx))[0]] # non-nanize
    # Remove xs before and after the integration limits
    mask      = np.where(np.logical_and(xi&lt;xx, xx&lt;xf))[0]
    xx        = np.hstack([[xi], xx[mask], [xf]])
    II        = []
    for xi, xf in zip(xx[:-1], xx[1:]):
        I = quad(integrand, xi, xf, full_output=1)
        if safe_mode:
            if I[0]!=0:
                if I[1]/I[0]&gt;1e-3:
                    raise RuntimeError(&#39;Error too large&#39;)
        II.append(I[0])
    return np.sum(II)</code></pre>
</details>
</dd>
<dt id="taurunner.track.utils.spline_column_depth.column_depth_helper"><code class="name flex">
<span>def <span class="ident">column_depth_helper</span></span>(<span>track, body)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def column_depth_helper(track, body):
    xx            = np.linspace(0, 1, 301)
    column_depths = np.append(0, np.cumsum([column_depth(track, body, x[0], x[1]) for x in zip(xx[:-1], xx[1:])]))
    # Pad arrays to help spline stability
    npad          = 5
    xpad          = np.linspace(0.01, 0.05, npad)
    padded_xx     = np.hstack([-xpad[::-1], xx, 1+xpad])
    padded_cds    = np.hstack([np.full(npad, column_depths[0]), column_depths, np.full(npad, column_depths[-1])])
    # Make the splines
    x_to_X_tck    = splrep(padded_xx, padded_cds)
    x_to_X        = lambda x: splev(x, x_to_X_tck)
    
    return column_depths[-1], x_to_X</code></pre>
</details>
</dd>
<dt id="taurunner.track.utils.spline_column_depth.construct_X2x"><code class="name flex">
<span>def <span class="ident">construct_X2x</span></span>(<span>x2X)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_X2x(x2X):
    if x2X(0)==x2X(1): # there is no bijection since derivative of this function must be non-neg
        print(x2X(0))
        if x2X(0.5)!=0: # This should only happen in the case that there is no column depth
            raise ValueError(&#39;Constant X2x is only allow for tracks with no column depth&#39;)
        else:
            def X2x(x):
                raise Exception(&#39;You should not be calling this for null propagations&#39;)
    else:
        xx         = np.linspace(0, 1, 301)
        cds        = [x2X(x) for x in xx]
        cds[0]     = 0 # Sometimes spline support can be imperfect
        X2x_tck    = splrep(cds, xx)
        def X2x(X):
            return splev(X, X2x_tck)[0]
    return X2x</code></pre>
</details>
</dd>
<dt id="taurunner.track.utils.spline_column_depth.get_hash"><code class="name flex">
<span>def <span class="ident">get_hash</span></span>(<span>track, body)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hash(track, body):
    s = f&#39;{body.radius}{track.depth}&#39;
    for bd in body.layer_boundaries:
        s += str(bd)
    s = s.replace(&#39;.&#39;, &#39;&#39;)
    hash_s = s
    #print(hash(str(s)))
    #hash_s = hash(s)
    #print(s, hash_s)
    return hash_s</code></pre>
</details>
</dd>
<dt id="taurunner.track.utils.spline_column_depth.set_spline"><code class="name flex">
<span>def <span class="ident">set_spline</span></span>(<span>track, body, npad=5)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_spline(track, body, npad=5):
    hash_s                   = get_hash(track, body)
    x2X_fname, spline_exists = spline_fname(hash_s)
    if spline_exists:
        with open(x2X_fname, &#39;rb&#39;) as pkl_file:
            x2X_spline =  pkl.load(pkl_file)
    else:
        from taurunner.track import chord
        if track.depth==0:
            skip = True
        else:
            skip = False
        ths = np.arccos(np.linspace(-1, 1, 500))
        chs = [chord(theta=th, depth=track.depth) for th in ths]
        xx  = np.linspace(0, 1, 301)
        res = np.zeros((ths.shape[0], xx.shape[0]))
        for i, ch in enumerate(chs):
            if skip and np.cos(ch.theta)&lt;=0:
                continue
            tot_X, x2X = column_depth_helper(ch, body)
            for j, x in enumerate(xx):
                res[i,j] = x2X(x)
        res[np.where(res&lt;=0)] = np.min(res[np.where(res&gt;0)])
        x2X_spline = RectBivariateSpline(np.cos(ths), xx, res, kx=2, ky=2)
        with open(x2X_fname, &#39;wb&#39;) as pkl_f:
            pkl.dump(x2X_spline, pkl_f)
    
    # reduce dimensionality of the spline to the desired theta    
    x2X = lambda x: x2X_spline(np.cos(track.theta), x)[0]
    tot_X = x2X(1)
    
    # Construct the X2x on the fly
    X2x = construct_X2x(x2X)
    
    #X2x = lambda X: X2x_spline(np.cos(track.theta), np.log(X))[0]
    track._column_depth_lookup[hash_s] = (tot_X, x2X, X2x)</code></pre>
</details>
</dd>
<dt id="taurunner.track.utils.spline_column_depth.spline_fname"><code class="name flex">
<span>def <span class="ident">spline_fname</span></span>(<span>hash_s)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spline_fname(hash_s):
    x2X_fname = f&#39;{SPLINE_PATH}/{hash_s}_x_to_X.pkl&#39;
    spline_exists = os.path.isfile(x2X_fname)
    return x2X_fname, spline_exists</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="taurunner.track.utils" href="index.html">taurunner.track.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="taurunner.track.utils.spline_column_depth.column_depth" href="#taurunner.track.utils.spline_column_depth.column_depth">column_depth</a></code></li>
<li><code><a title="taurunner.track.utils.spline_column_depth.column_depth_helper" href="#taurunner.track.utils.spline_column_depth.column_depth_helper">column_depth_helper</a></code></li>
<li><code><a title="taurunner.track.utils.spline_column_depth.construct_X2x" href="#taurunner.track.utils.spline_column_depth.construct_X2x">construct_X2x</a></code></li>
<li><code><a title="taurunner.track.utils.spline_column_depth.get_hash" href="#taurunner.track.utils.spline_column_depth.get_hash">get_hash</a></code></li>
<li><code><a title="taurunner.track.utils.spline_column_depth.set_spline" href="#taurunner.track.utils.spline_column_depth.set_spline">set_spline</a></code></li>
<li><code><a title="taurunner.track.utils.spline_column_depth.spline_fname" href="#taurunner.track.utils.spline_column_depth.spline_fname">spline_fname</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>